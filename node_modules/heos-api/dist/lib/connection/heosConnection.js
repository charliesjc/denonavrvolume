"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var heosCommand_1 = require("../write/heosCommand");
/**
 * An object representing a connection with a HEOS device, and provides methods to communicate with the connected HEOS device.
 * @remark All the methods returns a HeosConnection which means that they are chainable.
 */
var HeosConnection = /** @class */ (function () {
    function HeosConnection(on, once, onAll, socket) {
        var _this = this;
        this.closed = false;
        this.on = function (event, listener) {
            if (_this.closed) {
                console.warn('You are trying to add an event listener to a closed HeosConnection.');
            }
            else {
                on(event, listener);
            }
            return _this;
        };
        this.once = function (event, listener) {
            if (_this.closed) {
                console.warn('You are trying to add an event listener to a closed HeosConnection.');
            }
            else {
                once(event, listener);
            }
            return _this;
        };
        this.onAll = function (listener) {
            if (_this.closed) {
                console.warn('You are trying to add an event listener to a closed HeosConnection.');
            }
            else {
                onAll(listener);
            }
            return _this;
        };
        this.socket = socket;
    }
    /**
     * Sends a command to the connected HEOS device. Check the [HEOS CLI Protocol Specification](http://rn.dmglobal.com/euheos/HEOS_CLI_ProtocolSpecification.pdf) to learn all the commands that can be sent.
     * @param commandGroup The command group
     * @param command The command to send
     * @param attributes Optional attributes to include with the command
     * @returns A HeosConnection
     */
    HeosConnection.prototype.write = function (commandGroup, command, attributes) {
        if (this.closed) {
            console.warn('You are trying to write to a closed HeosConnection.');
        }
        else {
            this.socket.write(heosCommand_1.generateHeosCommand(commandGroup, command, attributes));
        }
        return this;
    };
    /**
     * Closes the HeosConnection. It is still possible that the connected HEOS Device will send messages after calling this command.
     * @returns A promise that resolves when the connection is finished. No messages will be sent from the HEOS Device after the promise is resolved.
     */
    HeosConnection.prototype.close = function () {
        var _this = this;
        this.closed = true;
        return new Promise(function (resolve) {
            _this.socket.end('', undefined, resolve);
        });
    };
    /**
     * Adds an event listener for when the connection is closed
     * @param listener A callback that is called when the connection is closed. `hadError` is true if there was a transmission error.
     */
    HeosConnection.prototype.onClose = function (listener) {
        this.socket.on('close', listener);
        return this;
    };
    /**
     * Adds an event listener for when an error occurs.
     * @param listener A callback thar is called when an error occurs.
     */
    HeosConnection.prototype.onError = function (listener) {
        this.socket.on('error', listener);
        return this;
    };
    return HeosConnection;
}());
exports.HeosConnection = HeosConnection;
//# sourceMappingURL=heosConnection.js.map