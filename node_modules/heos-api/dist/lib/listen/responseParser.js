"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var heosCommand_1 = require("./heosCommand");
var heosResponse_1 = require("./heosResponse");
var messageDelimiter = '\r\n';
function isValidHeosResponseMessage(message) {
    if (!Object.keys(message).length ||
        (message.hasOwnProperty('unparsed') &&
            typeof message.unparsed === 'string' &&
            (!message.hasOwnProperty('parsed') ||
                (message.hasOwnProperty('parsed') && typeof message.parsed === 'object')))) {
        return true;
    }
    return false;
}
function isCorrectResponse(response) {
    return (response.hasOwnProperty('heos') &&
        response.heos.hasOwnProperty('command') &&
        typeof response.heos.command === 'string');
}
function isHeosResponse(response) {
    if (response.hasOwnProperty('heos')) {
        var heos = response.heos;
        if (heos.hasOwnProperty('command') &&
            heos.hasOwnProperty('result') &&
            heos.hasOwnProperty('message')) {
            if (typeof heos.command === 'object' &&
                typeof heos.result === 'string' &&
                typeof heos.message === 'object' &&
                isValidHeosResponseMessage(heos.message)) {
                if (heos.command.hasOwnProperty('commandGroup') &&
                    heos.command.hasOwnProperty('command')) {
                    if (typeof heos.command.commandGroup === 'string' &&
                        typeof heos.command.command === 'string') {
                        return true;
                    }
                }
            }
        }
    }
    return false;
}
function isHeosEvent(response) {
    if (response.hasOwnProperty('heos')) {
        var heos = response.heos;
        if (heos.hasOwnProperty('command')) {
            if (typeof heos.command === 'object' &&
                heos.command.hasOwnProperty('commandGroup') &&
                heos.command.hasOwnProperty('command') &&
                typeof heos.command.commandGroup === 'string' &&
                typeof heos.command.command === 'string') {
                if (heos.hasOwnProperty('message') && typeof heos.message === 'object') {
                    return isValidHeosResponseMessage(heos.message);
                }
                else {
                    return true;
                }
            }
        }
    }
    return false;
}
var ResponseParser = /** @class */ (function () {
    function ResponseParser(callback) {
        this.buffer = '';
        this.callback = callback;
    }
    ResponseParser.prototype.put = function (data) {
        var _this = this;
        this.buffer += data;
        var messages = this.buffer.split(messageDelimiter);
        var lastMessage = messages.pop();
        if (lastMessage === '') {
            messages.push(lastMessage);
            this.buffer = '';
        }
        else {
            this.buffer = lastMessage || '';
        }
        try {
            messages
                .filter(function (row) { return row.length > 0; })
                .map(function (message) { return JSON.parse(message); })
                .map(function (response) {
                if (isCorrectResponse) {
                    return response;
                }
                else {
                    throw new TypeError();
                }
            })
                .map(function (response) {
                var command = heosCommand_1.parseHeosCommandString(response.heos.command);
                response.heos.command = command;
                return response;
            })
                .map(function (response) {
                var message = heosResponse_1.parseHeosMessageString(response.heos.message);
                response.heos.message = message;
                return response;
            })
                .map(function (response) {
                if (isHeosResponse(response) || isHeosEvent(response)) {
                    return response;
                }
                else {
                    throw new TypeError();
                }
            })
                .forEach(function (response) {
                try {
                    _this.callback(response);
                }
                catch (error) {
                    console.log('Error handling response');
                }
            });
        }
        catch (error) {
            if (error instanceof TypeError) {
                console.log('Heos response has wrong structure. Flushing buffer.');
            }
            else {
                console.log('Error parsing incoming messages. Flushing buffer.');
            }
            this.buffer = '';
        }
    };
    return ResponseParser;
}());
exports.ResponseParser = ResponseParser;
//# sourceMappingURL=responseParser.js.map